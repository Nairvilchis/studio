
'use server';
/**
 * @fileOverview Manages vehicle brand (MarcaVehiculo) operations with MongoDB.
 * Brand IDs (`_id`) are MongoDB ObjectIds (strings). Model IDs (`idModelo`) are also MongoDB ObjectIds (strings),
 * unique within their parent MarcaVehiculo's 'modelos' array.
 */

import { ObjectId, type Collection, type InsertOneResult, type UpdateResult, type DeleteResult, type Filter } from 'mongodb';
import { connectDB } from './db';
import type { MarcaVehiculo, ModeloVehiculo, NewMarcaData, UpdateMarcaData } from '@/lib/types';

/**
 * Class responsible for managing CRUD operations for Marcas (vehicle brands)
 * and their associated Modelos (vehicle models) in the MongoDB database.
 */
class MarcaManager {
  private collectionPromise: Promise<Collection<MarcaVehiculo>>;

  constructor() {
    this.collectionPromise = connectDB().then(db => {
      const marcasCollection = db.collection<MarcaVehiculo>('marcas');
      // Index on Marca name for uniqueness and fast lookups.
      // The collection stores `marca` field, not `nombre`.
      marcasCollection.createIndex({ marca: 1 }, { unique: true }).catch(err => {
        if (err.code !== 11000) console.warn('Failed to create index on marcas.marca:', err);
      });
      // Index on modelo ID for potential direct lookups if ever needed.
      marcasCollection.createIndex({ "modelos.idModelo": 1 }).catch(err => {
         if (err.code !== 11000) console.warn('Failed to create index on marcas.modelos.idModelo:', err);
      });
      return marcasCollection;
    }).catch(err => {
      console.error('Error al obtener la colección de marcas:', err);
      throw err; // Re-throw to be caught by the caller or crash the server if unhandled at startup.
    });
  }

  /**
   * Retrieves the MongoDB collection for marcas.
   * This method ensures the collection is initialized before use.
   * @returns {Promise<Collection<MarcaVehiculo>>} The marca collection.
   */
  private async getCollection(): Promise<Collection<MarcaVehiculo>> {
    return this.collectionPromise;
  }

  /**
   * Creates a new MarcaVehiculo.
   * The `_id` for the MarcaVehiculo is automatically generated by MongoDB.
   * Any initial modelos provided will also have their `idModelo` (ObjectId string) generated.
   * @param {NewMarcaData} marcaData Data for the new marca (marca name, optional initial modelos).
   * @returns {Promise<ObjectId | null>} The MongoDB ObjectId of the newly created marca, or null on failure.
   * @throws Will throw an error if the marca name is duplicate or other database errors occur.
   */
  async createMarca(marcaData: NewMarcaData): Promise<ObjectId | null> {
    const collection = await this.getCollection();
    
    if (!marcaData.marca || !marcaData.marca.trim()) {
      throw new Error('El nombre de la marca es requerido.');
    }

    const newMarcaDocument: Omit<MarcaVehiculo, '_id'> & { _id?: ObjectId } = {
      marca: marcaData.marca,
      // Initialize modelos as an empty array if not provided, or map provided modelos generating ObjectId strings.
      modelos: (marcaData.modelos || []).map(mod => ({
        ...mod, // Spread other modelo data if provided (e.g., 'modelo' name)
        idModelo: new ObjectId().toHexString(), // Generate new ObjectId string for each initial model
      })),
    };

    try {
      // Insert the new marca document. MongoDB generates the `_id`.
      const result: InsertOneResult<MarcaVehiculo> = await collection.insertOne(newMarcaDocument as MarcaVehiculo);
      console.log('Marca creada con ID de MongoDB:', result.insertedId);
      return result.insertedId; // Return the ObjectId of the inserted document.
    } catch (error: any) {
      console.error('Error al crear marca:', error);
      if (error.code === 11000 && error.message.includes('marca_1')) {
        throw new Error(`La marca con el nombre "${newMarcaDocument.marca}" ya existe.`);
      }
      throw error; // Re-throw other errors.
    }
  }

  /**
   * Retrieves all marcas, sorted by name.
   * @param {Filter<MarcaVehiculo>} [filter] Optional MongoDB filter.
   * @returns {Promise<MarcaVehiculo[]>} A list of marcas, with `_id` as string.
   * @throws Will throw if there's a database error.
   */
  async getAllMarcas(filter?: Filter<MarcaVehiculo>): Promise<MarcaVehiculo[]> {
    const collection = await this.getCollection();
    try {
      const marcasFromDb = await collection.find(filter || {}).sort({ marca: 1 }).toArray();
      // Convert MongoDB ObjectId (_id) to string for client-side consumption.
      return marcasFromDb.map(m => ({ ...m, _id: m._id.toHexString() }));
    } catch (error) {
      console.error('Error al obtener marcas:', error);
      throw error;
    }
  }

  /**
   * Retrieves a single marca by its MongoDB ObjectId (as a string).
   * @param {string} id The MongoDB ObjectId string of the marca.
   * @returns {Promise<MarcaVehiculo | null>} The marca object with `_id` as string, or null if not found or ID is invalid.
   * @throws Will throw if there's a database error.
   */
  async getMarcaById(id: string): Promise<MarcaVehiculo | null> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para getMarcaById:', id);
        return null;
      }
      const marcaFromDb = await collection.findOne({ _id: new ObjectId(id) });
      if (marcaFromDb) {
        // Convert _id to string before returning.
        return { ...marcaFromDb, _id: marcaFromDb._id.toHexString() };
      }
      return null; // Return null if no marca is found.
    } catch (error) {
      console.error('Error al obtener marca por ID de MongoDB:', error);
      throw error;
    }
  }

  /**
   * Updates a marca's data (only the 'marca' name).
   * The `modelos` array is managed by specific dedicated methods.
   * @param {string} id The MongoDB ObjectId string of the marca to update.
   * @param {UpdateMarcaData} updateData Data to update (only `marca` name).
   * @returns {Promise<boolean>} True if the update was successful (modified count > 0), false otherwise.
   * @throws Will throw an error if the updated name is duplicate or other database errors occur.
   */
  async updateMarca(id: string, updateData: UpdateMarcaData): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para updateMarca:', id);
        return false;
      }
      // `UpdateMarcaData` type only allows 'marca' field. If empty or no changes, return true.
      if (!updateData.marca || !updateData.marca.trim()) {
        throw new Error("El nombre de la marca no puede estar vacío para actualizar.");
      }
      
      // Perform the update operation.
      const result: UpdateResult = await collection.updateOne(
        { _id: new ObjectId(id) }, // Filter by _id.
        { $set: { marca: updateData.marca } } // Set the new marca name.
      );
      return result.modifiedCount > 0; // Return true if at least one document was modified.
    } catch (error: any) {
      console.error('Error al actualizar marca:', error);
      // Handle duplicate name error if 'marca' is part of updateData and unique index is violated.
      if (error.code === 11000 && updateData.marca) {
         throw new Error(`El nombre de marca "${updateData.marca}" ya está en uso.`);
      }
      throw error;
    }
  }

  /**
   * Deletes a marca from the database.
   * This will also delete all associated modelos as they are embedded.
   * @param {string} id The MongoDB ObjectId string of the marca to delete.
   * @returns {Promise<boolean>} True if the marca was deleted (deleted count > 0), false otherwise.
   * @throws Will throw if there's a database error.
   */
  async deleteMarca(id: string): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para deleteMarca:', id);
        return false;
      }
      // Perform the delete operation.
      const result: DeleteResult = await collection.deleteOne({ _id: new ObjectId(id) });
      return result.deletedCount > 0; // Return true if at least one document was deleted.
    } catch (error) {
      console.error('Error al eliminar marca:', error);
      throw error;
    }
  }

  // --- Modelo Management ---

  /**
   * Adds a modelo to a specific marca.
   * Generates a new ObjectId (as a hex string) for the modelo's `idModelo`.
   * Checks for duplicate modelo names within the same marca.
   * @param {string} marcaId The MongoDB ObjectId string of the parent marca.
   * @param {Omit<ModeloVehiculo, 'idModelo'>} modeloData Data for the new modelo (modelo name).
   * @returns {Promise<ModeloVehiculo | null>} The newly added modelo object (with its generated `idModelo`), or null on failure.
   * @throws Error if a modelo with the same name already exists in the marca, or if `marcaId` is invalid.
   */
  async addModeloToMarca(marcaId: string, modeloData: Omit<ModeloVehiculo, 'idModelo'>): Promise<ModeloVehiculo | null> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(marcaId)) {
        console.warn('Invalid ObjectId for addModeloToMarca (marcaId):', marcaId);
        throw new Error("ID de marca inválido.");
      }
      if (!modeloData.modelo || !modeloData.modelo.trim()) {
        throw new Error("El nombre del modelo es requerido.");
      }

      const mongoMarcaId = new ObjectId(marcaId);
      
      // Fetch the marca to check for duplicate modelo names.
      const marca = await collection.findOne({ _id: mongoMarcaId });
      if (!marca) {
        throw new Error("Marca no encontrada.");
      }
      if (marca.modelos?.some(m => m.modelo.toLowerCase() === modeloData.modelo.toLowerCase())) {
        throw new Error(`El modelo con nombre "${modeloData.modelo}" ya existe en esta marca.`);
      }

      // Create the new modelo object with a generated ObjectId string for idModelo.
      const newModelo: ModeloVehiculo = {
        ...modeloData, // Contains 'modelo' name
        idModelo: new ObjectId().toHexString(), // Generate new ObjectId string for idModelo
      };

      // Add the new modelo to the 'modelos' array of the specified marca.
      const result: UpdateResult = await collection.updateOne(
        { _id: mongoMarcaId },
        { $push: { modelos: newModelo } }
      );
      // Return the newModelo object if the update was successful.
      return result.modifiedCount > 0 ? newModelo : null;
    } catch (error) {
      console.error('Error al añadir modelo a marca:', error);
      throw error; // Re-throw to be handled by the server action.
    }
  }

  /**
   * Updates a modelo within a specific marca.
   * @param {string} marcaId The MongoDB ObjectId string of the parent marca.
   * @param {string} idModelo The ObjectId string of the modelo to update.
   * @param {Partial<Omit<ModeloVehiculo, 'idModelo'>>} modeloUpdateData Data to update (e.g., modelo name).
   * @returns {Promise<boolean>} True if the update was successful (modified count > 0), false otherwise.
   * @throws Error if trying to update to a name that already exists for another modelo in the same marca,
   *         or if IDs are invalid.
   */
  async updateModeloInMarca(marcaId: string, idModelo: string, modeloUpdateData: Partial<Omit<ModeloVehiculo, 'idModelo'>>): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(marcaId) || !ObjectId.isValid(idModelo)) {
        console.warn('Invalid ObjectId for updateModeloInMarca:', marcaId, idModelo);
        throw new Error("ID de marca o modelo inválido.");
      }
      // Ensure there's something to update.
      if (Object.keys(modeloUpdateData).length === 0) {
        return true; // No changes specified.
      }
      // Validate modelo name if provided.
      if (modeloUpdateData.modelo !== undefined && !modeloUpdateData.modelo.trim()) {
        throw new Error("El nombre del modelo no puede estar vacío.");
      }

      const mongoMarcaId = new ObjectId(marcaId);

      // If modelo name is being updated, check for duplicates among other modelos in the same marca.
      if (modeloUpdateData.modelo) {
        const marca = await collection.findOne({ 
          _id: mongoMarcaId, 
          "modelos.modelo": modeloUpdateData.modelo, // Check if new name exists
          "modelos.idModelo": { $ne: idModelo } // Exclude the current modelo being updated from the check
        });
        if (marca) {
          throw new Error(`Otro modelo con el nombre "${modeloUpdateData.modelo}" ya existe en esta marca.`);
        }
      }
      
      // Construct the $set object for MongoDB update to target the specific modelo in the array.
      const setUpdate: Record<string, any> = {};
      for (const key in modeloUpdateData) {
        if (Object.prototype.hasOwnProperty.call(modeloUpdateData, key)) {
          // Target the specific element in the 'modelos' array using $[elem].
          setUpdate[`modelos.$[elem].${key}`] = (modeloUpdateData as any)[key];
        }
      }

      // Perform the update operation using arrayFilters to target the correct modelo by its idModelo.
      const result: UpdateResult = await collection.updateOne(
        { _id: mongoMarcaId }, // Filter by marca _id.
        { $set: setUpdate },    // Set the new values for the matched modelo.
        { arrayFilters: [{ "elem.idModelo": idModelo }] } // Identify the modelo in the array.
      );
      return result.modifiedCount > 0;
    } catch (error) {
      console.error('Error al actualizar modelo en marca:', error);
      throw error; // Re-throw to be handled by the server action.
    }
  }

  /**
   * Removes a modelo from a specific marca.
   * @param {string} marcaId The MongoDB ObjectId string of the parent marca.
   * @param {string} idModelo The ObjectId string of the modelo to remove.
   * @returns {Promise<boolean>} True if the modelo was removed (modified count > 0), false otherwise.
   * @throws Will throw if there's a database error or if IDs are invalid.
   */
  async removeModeloFromMarca(marcaId: string, idModelo: string): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(marcaId) || !ObjectId.isValid(idModelo)) {
         console.warn('Invalid ObjectId for removeModeloFromMarca:', marcaId, idModelo);
        throw new Error("ID de marca o modelo inválido.");
      }
      // Use $pull to remove the modelo from the 'modelos' array based on its idModelo.
      const result: UpdateResult = await collection.updateOne(
        { _id: new ObjectId(marcaId) }, // Filter by marca _id.
        { $pull: { modelos: { idModelo: idModelo } } } // Specify the modelo to remove.
      );
      return result.modifiedCount > 0;
    } catch (error) {
      console.error('Error al eliminar modelo de marca:', error);
      throw error;
    }
  }
}

export default MarcaManager;
