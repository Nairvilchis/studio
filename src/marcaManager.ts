
'use server';
/**
 * @fileOverview Manages vehicle brand (MarcaVehiculo) operations with MongoDB.
 * Brand IDs (_id) are MongoDB ObjectIds. Model IDs (idModelo) are also ObjectIds (as strings)
 * and are unique within their parent MarcaVehiculo's 'modelos' array.
 */

import { ObjectId, type Collection, type InsertOneResult, type UpdateResult, type DeleteResult, type Filter } from 'mongodb';
import { connectDB } from './db';
import type { MarcaVehiculo, ModeloVehiculo, NewMarcaData, UpdateMarcaData } from '@/lib/types';

/**
 * Class responsible for managing CRUD operations for Marcas (vehicle brands)
 * and their associated Modelos (vehicle models) in the MongoDB database.
 */
class MarcaManager {
  private collectionPromise: Promise<Collection<MarcaVehiculo>>;

  constructor() {
    this.collectionPromise = connectDB().then(db => {
      const marcasCollection = db.collection<MarcaVehiculo>('marcas');
      // Index on Marca name for uniqueness and fast lookups.
      marcasCollection.createIndex({ marca: 1 }, { unique: true }).catch(err => {
        if (err.code !== 11000) console.warn('Failed to create index on marcas.marca:', err);
      });
      // Index on modelo ID for potential direct lookups if ever needed.
      marcasCollection.createIndex({ "modelos.idModelo": 1 }).catch(err => {
         if (err.code !== 11000) console.warn('Failed to create index on marcas.modelos.idModelo:', err);
      });
      return marcasCollection;
    }).catch(err => {
      console.error('Error al obtener la colección de marcas:', err);
      throw err;
    });
  }

  /**
   * Retrieves the MongoDB collection for marcas.
   * @returns {Promise<Collection<MarcaVehiculo>>} The marca collection.
   */
  private async getCollection(): Promise<Collection<MarcaVehiculo>> {
    return this.collectionPromise;
  }

  /**
   * Creates a new MarcaVehiculo.
   * The `_id` for the MarcaVehiculo is automatically generated by MongoDB.
   * @param {NewMarcaData} marcaData Data for the new marca (marca name, optional initial modelos).
   * @returns {Promise<ObjectId | null>} The MongoDB ObjectId of the newly created marca, or null on failure.
   * @throws Will throw an error if the marca name is duplicate or other database errors occur.
   */
  async createMarca(marcaData: NewMarcaData): Promise<ObjectId | null> {
    const collection = await this.getCollection();
    
    // Basic validation for required fields.
    if (!marcaData.marca || !marcaData.marca.trim()) {
      throw new Error('El nombre de la marca es requerido.');
    }

    // Prepare the document to be inserted.
    // _id is generated by MongoDB. modelos array is initialized if not provided.
    const newMarcaDocument: Omit<MarcaVehiculo, '_id'> & { _id?: ObjectId } = {
      marca: marcaData.marca,
      modelos: (marcaData.modelos || []).map(mod => ({
        ...mod,
        idModelo: new ObjectId().toHexString(), // Generate new ObjectId string for each initial model
      })),
    };

    try {
      const result: InsertOneResult<MarcaVehiculo> = await collection.insertOne(newMarcaDocument as MarcaVehiculo);
      console.log('Marca creada con ID de MongoDB:', result.insertedId);
      return result.insertedId;
    } catch (error: any) {
      console.error('Error al crear marca:', error);
      // Handle duplicate marca name error.
      if (error.code === 11000 && error.message.includes('marca_1')) {
        throw new Error(`La marca con el nombre "${newMarcaDocument.marca}" ya existe.`);
      }
      throw error;
    }
  }

  /**
   * Retrieves all marcas, sorted by name.
   * @param {Filter<MarcaVehiculo>} [filter] Optional MongoDB filter.
   * @returns {Promise<MarcaVehiculo[]>} A list of marcas, with `_id` as string.
   * @throws Will throw if there's a database error.
   */
  async getAllMarcas(filter?: Filter<MarcaVehiculo>): Promise<MarcaVehiculo[]> {
    const collection = await this.getCollection();
    try {
      const marcasFromDb = await collection.find(filter || {}).sort({ marca: 1 }).toArray();
      // Convert MongoDB ObjectId to string for client-side consumption.
      return marcasFromDb.map(m => ({ ...m, _id: m._id.toHexString() }));
    } catch (error) {
      console.error('Error al obtener marcas:', error);
      throw error;
    }
  }

  /**
   * Retrieves a single marca by its MongoDB ObjectId (as a string).
   * @param {string} id The MongoDB ObjectId string of the marca.
   * @returns {Promise<MarcaVehiculo | null>} The marca object with `_id` as string, or null if not found or ID is invalid.
   * @throws Will throw if there's a database error.
   */
  async getMarcaById(id: string): Promise<MarcaVehiculo | null> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para getMarcaById:', id);
        return null;
      }
      const marcaFromDb = await collection.findOne({ _id: new ObjectId(id) });
      if (marcaFromDb) {
        return { ...marcaFromDb, _id: marcaFromDb._id.toHexString() };
      }
      return null;
    } catch (error) {
      console.error('Error al obtener marca por ID de MongoDB:', error);
      throw error;
    }
  }

  /**
   * Updates a marca's data (excluding its modelos array, managed by specific methods).
   * @param {string} id The MongoDB ObjectId string of the marca to update.
   * @param {UpdateMarcaData} updateData Data to update (e.g., marca name).
   * @returns {Promise<boolean>} True if the update was successful, false otherwise.
   * @throws Will throw an error if the updated name is duplicate or other database errors occur.
   */
  async updateMarca(id: string, updateData: UpdateMarcaData): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para updateMarca:', id);
        return false;
      }
      if (Object.keys(updateData).length === 0) {
        return true; 
      }
      // Modelos array is managed by dedicated methods.
      const { modelos, ...dataToUpdate } = updateData; 
      if (Object.keys(dataToUpdate).length === 0) {
        return true;
      }

      const result: UpdateResult = await collection.updateOne(
        { _id: new ObjectId(id) },
        { $set: dataToUpdate }
      );
      return result.modifiedCount > 0;
    } catch (error: any) {
      console.error('Error al actualizar marca:', error);
      if (error.code === 11000 && updateData.marca) {
         throw new Error(`El nombre de marca "${updateData.marca}" ya está en uso.`);
      }
      throw error;
    }
  }

  /**
   * Deletes a marca from the database.
   * @param {string} id The MongoDB ObjectId string of the marca to delete.
   * @returns {Promise<boolean>} True if the marca was deleted, false otherwise.
   * @throws Will throw if there's a database error.
   */
  async deleteMarca(id: string): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para deleteMarca:', id);
        return false;
      }
      const result: DeleteResult = await collection.deleteOne({ _id: new ObjectId(id) });
      return result.deletedCount > 0;
    } catch (error) {
      console.error('Error al eliminar marca:', error);
      throw error;
    }
  }

  // --- Modelo Management ---

  /**
   * Adds a modelo to a specific marca.
   * Generates a new ObjectId (as a hex string) for the modelo's `idModelo`.
   * Checks for duplicate modelo names within the same marca.
   * @param {string} marcaId The MongoDB ObjectId string of the parent marca.
   * @param {Omit<ModeloVehiculo, 'idModelo'>} modeloData Data for the new modelo (modelo name).
   * @returns {Promise<ModeloVehiculo | null>} The newly added modelo object (with its generated `idModelo`), or null on failure.
   * @throws Error if a modelo with the same name already exists in the marca, or if `marcaId` is invalid.
   */
  async addModeloToMarca(marcaId: string, modeloData: Omit<ModeloVehiculo, 'idModelo'>): Promise<ModeloVehiculo | null> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(marcaId)) {
        console.warn('Invalid ObjectId for addModeloToMarca (marcaId):', marcaId);
        throw new Error("ID de marca inválido.");
      }
      if (!modeloData.modelo || !modeloData.modelo.trim()) {
        throw new Error("El nombre del modelo es requerido.");
      }

      const mongoMarcaId = new ObjectId(marcaId);
      
      const marca = await collection.findOne({ _id: mongoMarcaId });
      if (!marca) {
        throw new Error("Marca no encontrada.");
      }
      if (marca.modelos?.some(m => m.modelo.toLowerCase() === modeloData.modelo.toLowerCase())) {
        throw new Error(`El modelo con nombre "${modeloData.modelo}" ya existe en esta marca.`);
      }

      const newModelo: ModeloVehiculo = {
        ...modeloData,
        idModelo: new ObjectId().toHexString(), // Generate new ObjectId string for idModelo
      };

      const result: UpdateResult = await collection.updateOne(
        { _id: mongoMarcaId },
        { $push: { modelos: newModelo } }
      );
      return result.modifiedCount > 0 ? newModelo : null;
    } catch (error) {
      console.error('Error al añadir modelo a marca:', error);
      throw error;
    }
  }

  /**
   * Updates a modelo within a specific marca.
   * @param {string} marcaId The MongoDB ObjectId string of the parent marca.
   * @param {string} idModelo The ObjectId string of the modelo to update.
   * @param {Partial<Omit<ModeloVehiculo, 'idModelo'>>} modeloUpdateData Data to update (e.g., modelo name).
   * @returns {Promise<boolean>} True if the update was successful, false otherwise.
   * @throws Error if trying to update to a name that already exists for another modelo in the same marca,
   *         or if IDs are invalid.
   */
  async updateModeloInMarca(marcaId: string, idModelo: string, modeloUpdateData: Partial<Omit<ModeloVehiculo, 'idModelo'>>): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(marcaId) || !ObjectId.isValid(idModelo)) {
        console.warn('Invalid ObjectId for updateModeloInMarca:', marcaId, idModelo);
        throw new Error("ID de marca o modelo inválido.");
      }
      if (Object.keys(modeloUpdateData).length === 0) {
        return true;
      }
      if (modeloUpdateData.modelo !== undefined && !modeloUpdateData.modelo.trim()) {
        throw new Error("El nombre del modelo no puede estar vacío.");
      }

      const mongoMarcaId = new ObjectId(marcaId);

      if (modeloUpdateData.modelo) {
        const marca = await collection.findOne({ 
          _id: mongoMarcaId, 
          "modelos.modelo": modeloUpdateData.modelo,
          "modelos.idModelo": { $ne: idModelo } // Exclude the current modelo
        });
        if (marca) {
          throw new Error(`Otro modelo con el nombre "${modeloUpdateData.modelo}" ya existe en esta marca.`);
        }
      }
      
      const setUpdate: Record<string, any> = {};
      for (const key in modeloUpdateData) {
        if (Object.prototype.hasOwnProperty.call(modeloUpdateData, key)) {
          setUpdate[`modelos.$[elem].${key}`] = (modeloUpdateData as any)[key];
        }
      }

      const result: UpdateResult = await collection.updateOne(
        { _id: mongoMarcaId },
        { $set: setUpdate },
        { arrayFilters: [{ "elem.idModelo": idModelo }] }
      );
      return result.modifiedCount > 0;
    } catch (error) {
      console.error('Error al actualizar modelo en marca:', error);
      throw error;
    }
  }

  /**
   * Removes a modelo from a specific marca.
   * @param {string} marcaId The MongoDB ObjectId string of the parent marca.
   * @param {string} idModelo The ObjectId string of the modelo to remove.
   * @returns {Promise<boolean>} True if the modelo was removed, false otherwise.
   * @throws Will throw if there's a database error or if IDs are invalid.
   */
  async removeModeloFromMarca(marcaId: string, idModelo: string): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(marcaId) || !ObjectId.isValid(idModelo)) {
         console.warn('Invalid ObjectId for removeModeloFromMarca:', marcaId, idModelo);
        throw new Error("ID de marca o modelo inválido.");
      }
      const result: UpdateResult = await collection.updateOne(
        { _id: new ObjectId(marcaId) },
        { $pull: { modelos: { idModelo: idModelo } } }
      );
      return result.modifiedCount > 0;
    } catch (error) {
      console.error('Error al eliminar modelo de marca:', error);
      throw error;
    }
  }
}

export default MarcaManager;
