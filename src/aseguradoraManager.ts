
'use server';
/**
 * @fileOverview Manages insurance company (Aseguradora) operations with MongoDB.
 * Aseguradora IDs (_id) are MongoDB ObjectIds. Ajustador IDs (idAjustador) are also ObjectIds (as strings)
 * and are unique within their parent Aseguradora's 'ajustadores' array.
 */

import { ObjectId, type Collection, type InsertOneResult, type UpdateResult, type DeleteResult, type Filter } from 'mongodb';
import { connectDB } from './db';
import type { Aseguradora, Ajustador, NewAseguradoraData, UpdateAseguradoraData } from '@/lib/types';

/**
 * Class responsible for managing CRUD operations for Aseguradoras (insurance companies)
 * and their associated Ajustadores (adjusters) in the MongoDB database.
 */
class AseguradoraManager {
  private collectionPromise: Promise<Collection<Aseguradora>>;

  constructor() {
    this.collectionPromise = connectDB().then(db => {
      const aseguradorasCollection = db.collection<Aseguradora>('aseguradoras');
      // Index on Aseguradora name for uniqueness and fast lookups.
      aseguradorasCollection.createIndex({ nombre: 1 }, { unique: true }).catch(err => {
        // Log warning only if it's not a "duplicate key" error (index already exists)
        if (err.code !== 11000) console.warn('Failed to create index on aseguradoras.nombre:', err);
      });
      // Index on ajustador ID for potential direct lookups if ever needed, though less common.
      aseguradorasCollection.createIndex({ "ajustadores.idAjustador": 1 }).catch(err => {
         if (err.code !== 11000) console.warn('Failed to create index on aseguradoras.ajustadores.idAjustador:', err);
      });
      return aseguradorasCollection;
    }).catch(err => {
      console.error('Error al obtener la colección de aseguradoras:', err);
      throw err; // Re-throw to be caught by the caller or crash the server if unhandled at startup.
    });
  }

  /**
   * Retrieves the MongoDB collection for aseguradoras.
   * This method ensures the collection is initialized before use.
   * @returns {Promise<Collection<Aseguradora>>} The aseguradora collection.
   */
  private async getCollection(): Promise<Collection<Aseguradora>> {
    return this.collectionPromise;
  }

  /**
   * Creates a new Aseguradora.
   * The `_id` for the Aseguradora is automatically generated by MongoDB.
   * `idAjustador` for any provided ajustadores will be generated as new ObjectId hex strings.
   * @param {NewAseguradoraData} data Data for the new aseguradora.
   * @returns {Promise<ObjectId | null>} The MongoDB ObjectId of the newly created aseguradora, or null on failure.
   * @throws Will throw an error if the aseguradora name is duplicate or other database errors occur.
   */
  async createAseguradora(data: NewAseguradoraData): Promise<ObjectId | null> {
    const collection = await this.getCollection();

    // Basic validation for required fields.
    if (!data.nombre || !data.nombre.trim()) {
      throw new Error('El nombre de la aseguradora es requerido.');
    }
    
    // Prepare the document to be inserted.
    // Note: _id is not part of NewAseguradoraData and will be generated by MongoDB.
    const newAseguradoraDocument: Omit<Aseguradora, '_id'> & { _id?: ObjectId } = {
      nombre: data.nombre,
      telefono: data.telefono,
      ajustadores: (data.ajustadores || []).map(aj => ({
        ...aj, // Spread other ajustador data if provided in `data`
        idAjustador: new ObjectId().toHexString(), // Generate new ObjectId string for each adjuster
      })),
    };

    try {
      // Insert the new aseguradora document into the collection.
      const result: InsertOneResult<Aseguradora> = await collection.insertOne(newAseguradoraDocument as Aseguradora);
      console.log('Aseguradora creada con ID de MongoDB:', result.insertedId);
      return result.insertedId; // Return the ObjectId of the inserted document.
    } catch (error: any) {
      console.error('Error al crear aseguradora:', error);
      // Handle specific MongoDB errors, like duplicate key for 'nombre'.
      if (error.code === 11000 && error.message.includes('nombre_1')) {
        throw new Error(`La aseguradora con el nombre "${newAseguradoraDocument.nombre}" ya existe.`);
      }
      throw error; // Re-throw other errors.
    }
  }

  /**
   * Retrieves all aseguradoras, sorted by name.
   * @param {Filter<Aseguradora>} [filter] Optional MongoDB filter to apply to the query.
   * @returns {Promise<Aseguradora[]>} A list of all aseguradoras matching the filter, with `_id` as string.
   * @throws Will throw if there's a database error.
   */
  async getAllAseguradoras(filter?: Filter<Aseguradora>): Promise<Aseguradora[]> {
    const collection = await this.getCollection();
    try {
      const aseguradoras = await collection.find(filter || {}).sort({ nombre: 1 }).toArray();
      // Convert MongoDB ObjectId to string for client-side consumption.
      return aseguradoras.map(aseg => ({...aseg, _id: aseg._id.toHexString()}));
    } catch (error) {
      console.error('Error al obtener aseguradoras:', error);
      throw error;
    }
  }

  /**
   * Retrieves a single aseguradora by its MongoDB ObjectId (as a string).
   * @param {string} id The MongoDB ObjectId string of the aseguradora.
   * @returns {Promise<Aseguradora | null>} The aseguradora object with `_id` as string, or null if not found or ID is invalid.
   * @throws Will throw if there's a database error.
   */
  async getAseguradoraById(id: string): Promise<Aseguradora | null> {
    const collection = await this.getCollection();
    try {
      // Validate if the provided ID is a valid MongoDB ObjectId string.
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para getAseguradoraById:', id);
        return null;
      }
      // Find the aseguradora by its _id.
      const aseguradora = await collection.findOne({ _id: new ObjectId(id) });
      if (aseguradora) {
        // Convert _id to string before returning.
        return {...aseguradora, _id: aseguradora._id.toHexString()};
      }
      return null; // Return null if no aseguradora is found.
    } catch (error) {
      console.error('Error al obtener aseguradora por ID:', error);
      throw error;
    }
  }

  /**
   * Updates an aseguradora's data (excluding its ajustadores array, which is managed by specific methods).
   * @param {string} id The MongoDB ObjectId string of the aseguradora to update.
   * @param {UpdateAseguradoraData} updateData Data to update for the aseguradora (e.g., nombre, telefono).
   * @returns {Promise<boolean>} True if the update was successful (modified count > 0), false otherwise.
   * @throws Will throw an error if the updated name is duplicate or other database errors occur.
   */
  async updateAseguradora(id: string, updateData: UpdateAseguradoraData): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para updateAseguradora:', id);
        return false;
      }
      // If no data is provided for update, consider it a success (no changes needed).
      if (Object.keys(updateData).length === 0) {
        return true;
      }
      // The 'ajustadores' array is managed by dedicated methods, so exclude it from direct update here.
      const { ajustadores, ...dataToUpdate } = updateData;
      if (Object.keys(dataToUpdate).length === 0) {
        // If only 'ajustadores' was in updateData, it's ignored here, effectively no changes.
        return true; 
      }

      // Perform the update operation.
      const result: UpdateResult = await collection.updateOne(
        { _id: new ObjectId(id) }, // Filter by _id.
        { $set: dataToUpdate }      // Set the new values.
      );
      return result.modifiedCount > 0; // Return true if at least one document was modified.
    } catch (error: any) {
      console.error('Error al actualizar aseguradora:', error);
      // Handle duplicate name error if 'nombre' is part of updateData.
      if (error.code === 11000 && updateData.nombre) {
        throw new Error(`El nombre de aseguradora "${updateData.nombre}" ya está en uso.`);
      }
      throw error;
    }
  }

  /**
   * Deletes an aseguradora from the database.
   * @param {string} id The MongoDB ObjectId string of the aseguradora to delete.
   * @returns {Promise<boolean>} True if the aseguradora was deleted (deleted count > 0), false otherwise.
   * @throws Will throw if there's a database error.
   */
  async deleteAseguradora(id: string): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para deleteAseguradora:', id);
        return false;
      }
      // Perform the delete operation.
      const result: DeleteResult = await collection.deleteOne({ _id: new ObjectId(id) });
      return result.deletedCount > 0; // Return true if at least one document was deleted.
    } catch (error) {
      console.error('Error al eliminar aseguradora:', error);
      throw error;
    }
  }

  // --- Ajustador Management ---

  /**
   * Adds an ajustador to a specific aseguradora.
   * Generates a new ObjectId (as a hex string) for the ajustador's `idAjustador`.
   * Checks for duplicate ajustador names within the same aseguradora.
   * @param {string} aseguradoraId The MongoDB ObjectId string of the parent aseguradora.
   * @param {Omit<Ajustador, 'idAjustador'>} ajustadorData Data for the new ajustador (nombre, telefono, correo).
   * @returns {Promise<Ajustador | null>} The newly added ajustador object (with its generated `idAjustador`), or null on failure.
   * @throws Error if an adjuster with the same name already exists in the aseguradora, or if `aseguradoraId` is invalid.
   */
  async addAjustadorToAseguradora(aseguradoraId: string, ajustadorData: Omit<Ajustador, 'idAjustador'>): Promise<Ajustador | null> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(aseguradoraId)) {
        console.warn('Invalid ObjectId for addAjustadorToAseguradora (aseguradoraId):', aseguradoraId);
        throw new Error("ID de aseguradora inválido.");
      }
      if (!ajustadorData.nombre || !ajustadorData.nombre.trim()) {
        throw new Error("El nombre del ajustador es requerido.");
      }

      const mongoAseguradoraId = new ObjectId(aseguradoraId);
      
      // Check for duplicate ajustador name within this aseguradora before adding.
      const aseguradora = await collection.findOne({ _id: mongoAseguradoraId });
      if (!aseguradora) {
        throw new Error("Aseguradora no encontrada.");
      }
      if (aseguradora.ajustadores?.some(a => a.nombre.toLowerCase() === ajustadorData.nombre.toLowerCase())) {
        throw new Error(`El ajustador con nombre "${ajustadorData.nombre}" ya existe en esta aseguradora.`);
      }

      // Create the new ajustador object with a generated ObjectId string for idAjustador.
      const newAjustador: Ajustador = {
        ...ajustadorData,
        idAjustador: new ObjectId().toHexString(),
      };

      // Add the new ajustador to the 'ajustadores' array of the specified aseguradora.
      const result: UpdateResult = await collection.updateOne(
        { _id: mongoAseguradoraId },
        { $push: { ajustadores: newAjustador } }
      );
      // Return the newAjustador object if the update was successful.
      return result.modifiedCount > 0 ? newAjustador : null;
    } catch (error) {
      console.error('Error al añadir ajustador:', error);
      throw error; // Re-throw to be handled by the server action.
    }
  }

  /**
   * Updates an ajustador within a specific aseguradora.
   * @param {string} aseguradoraId The MongoDB ObjectId string of the parent aseguradora.
   * @param {string} idAjustador The ObjectId string of the ajustador to update.
   * @param {Partial<Omit<Ajustador, 'idAjustador'>>} ajustadorUpdateData Data to update for the ajustador.
   * @returns {Promise<boolean>} True if the update was successful (modified count > 0), false otherwise.
   * @throws Error if trying to update to a name that already exists for another adjuster in the same aseguradora,
   *         or if IDs are invalid.
   */
  async updateAjustadorInAseguradora(aseguradoraId: string, idAjustador: string, ajustadorUpdateData: Partial<Omit<Ajustador, 'idAjustador'>>): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      // Validate ObjectIds.
      if (!ObjectId.isValid(aseguradoraId) || !ObjectId.isValid(idAjustador)) {
        console.warn('Invalid ObjectId for updateAjustadorInAseguradora:', aseguradoraId, idAjustador);
        throw new Error("ID de aseguradora o ajustador inválido.");
      }
      if (Object.keys(ajustadorUpdateData).length === 0) {
        return true; // No changes specified.
      }
      // Validate name if provided.
      if (ajustadorUpdateData.nombre !== undefined && !ajustadorUpdateData.nombre.trim()) {
        throw new Error("El nombre del ajustador no puede estar vacío.");
      }

      const mongoAseguradoraId = new ObjectId(aseguradoraId);

      // If name is being updated, check for duplicates among other ajustadores.
      if (ajustadorUpdateData.nombre) {
        const aseguradora = await collection.findOne({ 
          _id: mongoAseguradoraId, 
          "ajustadores.nombre": ajustadorUpdateData.nombre,
          "ajustadores.idAjustador": { $ne: idAjustador } // Exclude the current ajustador from the check.
        });
        if (aseguradora) {
          throw new Error(`Otro ajustador con el nombre "${ajustadorUpdateData.nombre}" ya existe en esta aseguradora.`);
        }
      }
      
      // Construct the $set object for MongoDB update.
      const setUpdate: Record<string, any> = {};
      for (const key in ajustadorUpdateData) {
        if (Object.prototype.hasOwnProperty.call(ajustadorUpdateData, key)) {
          // Target the specific element in the 'ajustadores' array.
          setUpdate[`ajustadores.$[elem].${key}`] = (ajustadorUpdateData as any)[key];
        }
      }

      // Perform the update operation using arrayFilters to target the correct ajustador.
      const result: UpdateResult = await collection.updateOne(
        { _id: mongoAseguradoraId },
        { $set: setUpdate },
        { arrayFilters: [{ "elem.idAjustador": idAjustador }] }
      );
      return result.modifiedCount > 0;
    } catch (error) {
      console.error('Error al actualizar ajustador:', error);
      throw error; // Re-throw to be handled by the server action.
    }
  }

  /**
   * Removes an ajustador from a specific aseguradora.
   * @param {string} aseguradoraId The MongoDB ObjectId string of the parent aseguradora.
   * @param {string} idAjustador The ObjectId string of the ajustador to remove.
   * @returns {Promise<boolean>} True if the ajustador was removed (modified count > 0), false otherwise.
   * @throws Will throw if there's a database error or if IDs are invalid.
   */
  async removeAjustadorFromAseguradora(aseguradoraId: string, idAjustador: string): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(aseguradoraId) || !ObjectId.isValid(idAjustador)) {
         console.warn('Invalid ObjectId for removeAjustadorFromAseguradora:', aseguradoraId, idAjustador);
        throw new Error("ID de aseguradora o ajustador inválido.");
      }
      // Use $pull to remove the ajustador from the 'ajustadores' array.
      const result: UpdateResult = await collection.updateOne(
        { _id: new ObjectId(aseguradoraId) },
        { $pull: { ajustadores: { idAjustador: idAjustador } } }
      );
      return result.modifiedCount > 0;
    } catch (error) {
      console.error('Error al eliminar ajustador:', error);
      throw error;
    }
  }
}

export default AseguradoraManager;

