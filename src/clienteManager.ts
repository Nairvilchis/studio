
'use server';
/**
 * @fileOverview Manages client (Cliente) operations with MongoDB.
 * Client IDs (`_id`) are MongoDB ObjectIds.
 */

import { ObjectId, type Collection, type InsertOneResult, type UpdateResult, type DeleteResult, type Filter } from 'mongodb';
import { connectDB } from './db';
import type { Cliente, NewClienteData, UpdateClienteData } from '@/lib/types';

/**
 * Class responsible for managing CRUD operations for Clientes in the MongoDB database.
 */
class ClienteManager {
  private collectionPromise: Promise<Collection<Cliente>>;

  constructor() {
    this.collectionPromise = connectDB().then(db => {
      const clientesCollection = db.collection<Cliente>('clientes');
      // Index on Cliente name for fast lookups or sorting. Uniqueness is not enforced here
      // as multiple clients might share a common name (e.g., "Juan Pérez").
      // Consider adding a unique index on 'rfc' or 'correo' if those should be unique.
      clientesCollection.createIndex({ nombre: 1 }).catch(err => {
        if (err.code !== 11000) console.warn('Failed to create index on clientes.nombre:', err);
      });
      clientesCollection.createIndex({ correo: 1 }, { unique: true, sparse: true }).catch(err => {
        if (err.code !== 11000) console.warn('Failed to create unique sparse index on clientes.correo:', err);
      });
       clientesCollection.createIndex({ rfc: 1 }, { unique: true, sparse: true }).catch(err => {
        if (err.code !== 11000) console.warn('Failed to create unique sparse index on clientes.rfc:', err);
      });
      return clientesCollection;
    }).catch(err => {
      console.error('Error al obtener la colección de clientes:', err);
      throw err; 
    });
  }

  /**
   * Retrieves the MongoDB collection for clientes.
   * @returns {Promise<Collection<Cliente>>} The cliente collection.
   */
  private async getCollection(): Promise<Collection<Cliente>> {
    return this.collectionPromise;
  }

  /**
   * Creates a new Cliente.
   * The `_id` for the Cliente is automatically generated by MongoDB.
   * The `ordenes` array is initialized as empty.
   * @param {NewClienteData} data Data for the new cliente (nombre, telefono, correo, rfc).
   * @returns {Promise<ObjectId | null>} The MongoDB ObjectId of the newly created cliente, or null on failure.
   * @throws Will throw an error if the cliente name is missing or other database errors occur.
   */
  async createCliente(data: NewClienteData): Promise<ObjectId | null> {
    const collection = await this.getCollection();

    if (!data.nombre || !data.nombre.trim()) {
      throw new Error('El nombre del cliente es requerido.');
    }
    
    const newClienteDocument: Omit<Cliente, '_id'> = {
      nombre: data.nombre,
      telefono: data.telefono,
      correo: data.correo,
      rfc: data.rfc,
      ordenes: [], // Initialize 'ordenes' as an empty array.
    };

    try {
      const result: InsertOneResult<Cliente> = await collection.insertOne(newClienteDocument as Cliente);
      console.log('Cliente creado con ID de MongoDB:', result.insertedId);
      return result.insertedId;
    } catch (error: any) {
      console.error('Error al crear cliente:', error);
      if (error.code === 11000) { // Duplicate key error
        if (error.message.includes('correo_1')) {
          throw new Error(`El correo "${data.correo}" ya está registrado.`);
        }
        if (error.message.includes('rfc_1')) {
          throw new Error(`El RFC "${data.rfc}" ya está registrado.`);
        }
      }
      throw error;
    }
  }

  /**
   * Retrieves all clientes, sorted by name.
   * @param {Filter<Cliente>} [filter] Optional MongoDB filter to apply to the query.
   * @returns {Promise<Cliente[]>} A list of all clientes matching the filter, with `_id` as string.
   * @throws Will throw if there's a database error.
   */
  async getAllClientes(filter?: Filter<Cliente>): Promise<Cliente[]> {
    const collection = await this.getCollection();
    try {
      const clientesFromDb = await collection.find(filter || {}).sort({ nombre: 1 }).toArray();
      // Convert MongoDB ObjectId to string for client-side consumption.
      return clientesFromDb.map(cli => ({...cli, _id: cli._id.toHexString()}));
    } catch (error) {
      console.error('Error al obtener clientes:', error);
      throw error;
    }
  }

  /**
   * Retrieves a single cliente by its MongoDB ObjectId (as a string).
   * @param {string} id The MongoDB ObjectId string of the cliente.
   * @returns {Promise<Cliente | null>} The cliente object with `_id` as string, or null if not found or ID is invalid.
   * @throws Will throw if there's a database error.
   */
  async getClienteById(id: string): Promise<Cliente | null> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para getClienteById:', id);
        return null;
      }
      const clienteFromDb = await collection.findOne({ _id: new ObjectId(id) });
      if (clienteFromDb) {
        return {...clienteFromDb, _id: clienteFromDb._id.toHexString()};
      }
      return null;
    } catch (error) {
      console.error('Error al obtener cliente por ID de MongoDB:', error);
      throw error;
    }
  }

  /**
   * Updates a cliente's data.
   * @param {string} id The MongoDB ObjectId string of the cliente to update.
   * @param {UpdateClienteData} updateData Data to update for the cliente.
   * @returns {Promise<boolean>} True if the update was successful (modified count > 0), false otherwise.
   * @throws Will throw an error if database errors occur (e.g., duplicate unique field).
   */
  async updateCliente(id: string, updateData: UpdateClienteData): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para updateCliente:', id);
        return false;
      }
      if (Object.keys(updateData).length === 0) {
        return true; // No changes needed
      }
      if (updateData.nombre !== undefined && !updateData.nombre.trim()) {
        throw new Error("El nombre del cliente no puede estar vacío.");
      }

      const result: UpdateResult = await collection.updateOne(
        { _id: new ObjectId(id) },
        { $set: updateData }
      );
      return result.modifiedCount > 0;
    } catch (error: any) {
      console.error('Error al actualizar cliente:', error);
       if (error.code === 11000) {
        if (updateData.correo && error.message.includes('correo_1')) {
          throw new Error(`El correo "${updateData.correo}" ya está registrado.`);
        }
        if (updateData.rfc && error.message.includes('rfc_1')) {
          throw new Error(`El RFC "${updateData.rfc}" ya está registrado.`);
        }
      }
      throw error;
    }
  }

  /**
   * Deletes a cliente from the database.
   * @param {string} id The MongoDB ObjectId string of the cliente to delete.
   * @returns {Promise<boolean>} True if the cliente was deleted (deleted count > 0), false otherwise.
   * @throws Will throw if there's a database error.
   */
  async deleteCliente(id: string): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para deleteCliente:', id);
        return false;
      }
      const result: DeleteResult = await collection.deleteOne({ _id: new ObjectId(id) });
      return result.deletedCount > 0;
    } catch (error) {
      console.error('Error al eliminar cliente:', error);
      throw error;
    }
  }

  /**
   * Adds a reference to an order to the cliente's 'ordenes' array.
   * This method is optional for the current step but demonstrates how to link orders.
   * @param {string} clienteId The _id (string ObjectId) of the cliente.
   * @param {string} orderId The _id (string ObjectId) of the order.
   * @returns {Promise<boolean>} True if the order reference was added, false otherwise.
   */
  async addOrderToCliente(clienteId: string, orderId: string): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(clienteId) || !ObjectId.isValid(orderId)) {
        console.warn('Invalid ObjectId for addOrderToCliente:', clienteId, orderId);
        return false;
      }
      const result = await collection.updateOne(
        { _id: new ObjectId(clienteId) },
        { $addToSet: { ordenes: { orderId: orderId } } } // Use $addToSet to avoid duplicate order entries
      );
      return result.modifiedCount > 0;
    } catch (error) {
      console.error('Error al añadir orden a cliente:', error);
      throw error;
    }
  }
}

export default ClienteManager;

    