
'use server';
/**
 * @fileOverview Manages "ColorVehiculo" (Vehicle Color) operations with MongoDB.
 * Colores are used to populate select options in order forms.
 * Each ColorVehiculo has a unique name.
 */

import { ObjectId, type Collection, type InsertOneResult, type UpdateResult, type DeleteResult } from 'mongodb';
import { connectDB } from './db';
import type { ColorVehiculo, NewColorVehiculoData, UpdateColorVehiculoData } from '@/lib/types';

/**
 * Class responsible for managing CRUD operations for ColoresVehiculo (Vehicle Colors)
 * in the MongoDB database.
 */
class ColorVehiculoManager {
  private collectionPromise: Promise<Collection<ColorVehiculo>>;

  constructor() {
    this.collectionPromise = connectDB().then(db => {
      const coloresCollection = db.collection<ColorVehiculo>('coloresVehiculos');
      // Index on ColorVehiculo name for uniqueness and fast lookups.
      coloresCollection.createIndex({ nombre: 1 }, { unique: true }).catch(err => {
        if (err.code !== 11000) console.warn('Failed to create index on coloresVehiculos.nombre:', err);
      });
      return coloresCollection;
    }).catch(err => {
      console.error('Error al obtener la colección de colores de vehículos:', err);
      throw err;
    });
  }

  /**
   * Retrieves the MongoDB collection for coloresVehiculos.
   * @returns {Promise<Collection<ColorVehiculo>>} The color collection.
   */
  private async getCollection(): Promise<Collection<ColorVehiculo>> {
    return this.collectionPromise;
  }

  /**
   * Creates a new ColorVehiculo.
   * The `_id` for the ColorVehiculo is automatically generated by MongoDB.
   * @param {NewColorVehiculoData} data - Data for the new color (nombre).
   * @returns {Promise<ObjectId | null>} The MongoDB ObjectId of the newly created color, or null on failure.
   * @throws Will throw an error if the color name is duplicate or other database errors occur.
   */
  async createColor(data: NewColorVehiculoData): Promise<ObjectId | null> {
    const collection = await this.getCollection();

    if (!data.nombre || !data.nombre.trim()) {
      throw new Error('El nombre del color es requerido.');
    }
    
    const newColorDocument: Omit<ColorVehiculo, '_id'> = {
      nombre: data.nombre,
    };

    try {
      const result: InsertOneResult<ColorVehiculo> = await collection.insertOne(newColorDocument as ColorVehiculo);
      console.log('Color de vehículo creado con ID de MongoDB:', result.insertedId);
      return result.insertedId;
    } catch (error: any) {
      console.error('Error al crear color de vehículo:', error);
      if (error.code === 11000 && error.message.includes('nombre_1')) {
        throw new Error(`El color con el nombre "${data.nombre}" ya existe.`);
      }
      throw error;
    }
  }

  /**
   * Retrieves all coloresVehiculo, sorted by name.
   * @returns {Promise<ColorVehiculo[]>} A list of all colores, with `_id` as string.
   * @throws Will throw if there's a database error.
   */
  async getAllColores(): Promise<ColorVehiculo[]> {
    const collection = await this.getCollection();
    try {
      const coloresFromDb = await collection.find({}).sort({ nombre: 1 }).toArray();
      return coloresFromDb.map(c => ({ ...c, _id: c._id.toHexString() }));
    } catch (error) {
      console.error('Error al obtener colores de vehículos:', error);
      throw error;
    }
  }
  
  /**
   * Retrieves a single color by its MongoDB ObjectId (as a string).
   * @param {string} id - The MongoDB ObjectId string of the color.
   * @returns {Promise<ColorVehiculo | null>} The color object with `_id` as string, or null if not found or ID is invalid.
   */
  async getColorById(id: string): Promise<ColorVehiculo | null> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para getColorById:', id);
        return null;
      }
      const colorFromDb = await collection.findOne({ _id: new ObjectId(id) });
      if (colorFromDb) {
        return { ...colorFromDb, _id: colorFromDb._id.toHexString() };
      }
      return null;
    } catch (error) {
      console.error('Error al obtener color por ID:', error);
      throw error;
    }
  }


  /**
   * Updates a color's name.
   * @param {string} id - The MongoDB ObjectId string of the color to update.
   * @param {UpdateColorVehiculoData} data - Data to update (only `nombre`).
   * @returns {Promise<boolean>} True if the update was successful (modified count > 0), false otherwise.
   * @throws Will throw an error if the updated name is duplicate or other database errors occur.
   */
  async updateColor(id: string, data: UpdateColorVehiculoData): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para updateColor:', id);
        return false;
      }
      if (!data.nombre || !data.nombre.trim()) {
        throw new Error("El nombre del color no puede estar vacío para actualizar.");
      }
      
      const result: UpdateResult = await collection.updateOne(
        { _id: new ObjectId(id) },
        { $set: { nombre: data.nombre } }
      );
      return result.modifiedCount > 0;
    } catch (error: any) {
      console.error('Error al actualizar color de vehículo:', error);
      if (error.code === 11000 && data.nombre) {
         throw new Error(`El nombre de color "${data.nombre}" ya está en uso.`);
      }
      throw error;
    }
  }

  /**
   * Deletes a color from the database.
   * @param {string} id - The MongoDB ObjectId string of the color to delete.
   * @returns {Promise<boolean>} True if the color was deleted (deleted count > 0), false otherwise.
   * @throws Will throw if there's a database error.
   */
  async deleteColor(id: string): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para deleteColor:', id);
        return false;
      }
      const result: DeleteResult = await collection.deleteOne({ _id: new ObjectId(id) });
      return result.deletedCount > 0;
    } catch (error) {
      console.error('Error al eliminar color de vehículo:', error);
      throw error;
    }
  }
}

export default ColorVehiculoManager;
