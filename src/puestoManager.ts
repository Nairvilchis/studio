
'use server';
/**
 * @fileOverview Manages "Puesto" (Job Position) operations with MongoDB.
 * Puestos are used to populate select options in employee forms.
 * Each Puesto has a unique name.
 * @remarks
 * Esta clase utiliza la directiva 'use server' para indicar que solo debe ejecutarse en el servidor.
 */

import { ObjectId, type Collection, type InsertOneResult, type UpdateResult, type DeleteResult, type Filter } from './db';
import { connectDB } from './db';
import type { Puesto, NewPuestoData, UpdatePuestoData } from '@/lib/types';

/**
 * Class responsible for managing CRUD operations for Puestos (Job Positions)
 * in the MongoDB database.
 */
class PuestoManager {
  private collectionPromise: Promise<Collection<Puesto>>;

  constructor() {
    this.collectionPromise = connectDB().then(db => {
      const puestosCollection = db.collection<Puesto>('puestos');
      // Index on Puesto name for uniqueness and fast lookups.
      puestosCollection.createIndex({ nombre: 1 }, { unique: true }).catch(err => {
        if (err.code !== 11000) console.warn('Failed to create index on puestos.nombre:', err);
      });
      return puestosCollection;
    }).catch(err => {
      console.error('Error al obtener la colección de puestos:', err);
      throw err;
    });
  }

  /**
   * Retrieves the MongoDB collection for puestos.
   * @returns {Promise<Collection<Puesto>>} The puesto collection.
   * @private
   */
  private async getCollection(): Promise<Collection<Puesto>> {
    return this.collectionPromise;
  }

  /**
   * Creates a new Puesto.
   * The `_id` for the Puesto is automatically generated by MongoDB.
   * @param {NewPuestoData} data - Data for the new puesto (nombre).
   * @returns {Promise<ObjectId | null>} The MongoDB ObjectId of the newly created puesto, or null on failure.
   * @throws Will throw an error if the puesto name is duplicate or other database errors occur.
   */
  async createPuesto(data: NewPuestoData): Promise<ObjectId | null> {
    const collection = await this.getCollection();

    if (!data.nombre || !data.nombre.trim()) {
      throw new Error('El nombre del puesto es requerido.');
    }
    
    const newPuestoDocument: Omit<Puesto, '_id'> = {
      nombre: data.nombre,
    };

    try {
      const result: InsertOneResult<Puesto> = await collection.insertOne(newPuestoDocument as Puesto);
      console.log('Puesto creado con ID de MongoDB:', result.insertedId);
      return result.insertedId;
    } catch (error: any) {
      console.error('Error al crear puesto:', error);
      if (error.code === 11000 && error.message.includes('nombre_1')) {
        throw new Error(`El puesto con el nombre "${data.nombre}" ya existe.`);
      }
      throw error;
    }
  }

  /**
   * Retrieves all puestos, sorted by name.
   * @returns {Promise<Puesto[]>} A list of all puestos, with `_id` as string.
   * @throws Will throw if there's a database error.
   */
  async getAllPuestos(): Promise<Puesto[]> {
    const collection = await this.getCollection();
    try {
      const puestosFromDb = await collection.find({}).sort({ nombre: 1 }).toArray();
      return puestosFromDb.map(p => ({ ...p, _id: p._id.toHexString() }));
    } catch (error) {
      console.error('Error al obtener puestos:', error);
      throw error;
    }
  }

  /**
   * Retrieves a single puesto by its MongoDB ObjectId (as a string).
   * @param {string} id - The MongoDB ObjectId string of the puesto.
   * @returns {Promise<Puesto | null>} The puesto object with `_id` as string, or null if not found or ID is invalid.
   * @throws Will throw if there's a database error.
   */
  async getPuestoById(id: string): Promise<Puesto | null> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para getPuestoById:', id);
        return null;
      }
      const puestoFromDb = await collection.findOne({ _id: new ObjectId(id) });
      if (puestoFromDb) {
        return { ...puestoFromDb, _id: puestoFromDb._id.toHexString() };
      }
      return null;
    } catch (error) {
      console.error('Error al obtener puesto por ID:', error);
      throw error;
    }
  }

  /**
   * Updates a puesto's name.
   * @param {string} id - The MongoDB ObjectId string of the puesto to update.
   * @param {UpdatePuestoData} data - Data to update (only `nombre`).
   * @returns {Promise<boolean>} True if the update was successful (modified count > 0), false otherwise.
   * @throws Will throw an error if the updated name is duplicate or other database errors occur.
   */
  async updatePuesto(id: string, data: UpdatePuestoData): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para updatePuesto:', id);
        return false;
      }
      if (!data.nombre || !data.nombre.trim()) {
        throw new Error("El nombre del puesto no puede estar vacío para actualizar.");
      }
      
      const result: UpdateResult = await collection.updateOne(
        { _id: new ObjectId(id) },
        { $set: { nombre: data.nombre } }
      );
      return result.modifiedCount > 0;
    } catch (error: any) {
      console.error('Error al actualizar puesto:', error);
      if (error.code === 11000 && data.nombre) {
         throw new Error(`El nombre de puesto "${data.nombre}" ya está en uso.`);
      }
      throw error;
    }
  }

  /**
   * Deletes a puesto from the database.
   * @param {string} id - The MongoDB ObjectId string of the puesto to delete.
   * @returns {Promise<boolean>} True if the puesto was deleted (deleted count > 0), false otherwise.
   * @throws Will throw if there's a database error.
   */
  async deletePuesto(id: string): Promise<boolean> {
    const collection = await this.getCollection();
    try {
      if (!ObjectId.isValid(id)) {
        console.warn('Formato de ObjectId inválido para deletePuesto:', id);
        return false;
      }
      const result: DeleteResult = await collection.deleteOne({ _id: new ObjectId(id) });
      return result.deletedCount > 0;
    } catch (error) {
      console.error('Error al eliminar puesto:', error);
      throw error;
    }
  }
}

export default PuestoManager;
